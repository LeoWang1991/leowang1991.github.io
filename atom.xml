<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lifelover</title>
  <subtitle>love life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-07T02:48:56.443Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>骁飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React官方文档学习笔记</title>
    <link href="http://yoursite.com/2017/12/04/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/12/04/React官方文档学习笔记/</id>
    <published>2017-12-04T09:18:07.000Z</published>
    <updated>2017-12-07T02:48:56.443Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇blog主要记录一下<a href="https://reactjs.org/" target="_blank" rel="external">React官网文档</a>学习笔记。</p>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><ol>
<li>组件名大写字母开头</li>
<li>props不设置value的话，默认为true<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Input autocomplete/&gt;  </div><div class="line">&lt;Input autocomplete=&#123;true&#125;/&gt;</div><div class="line">```  </div><div class="line">3. 对于Booleans,null undefined render()时候会忽略掉</div><div class="line"></div><div class="line">### 类型检测 </div><div class="line">1. propTypes来检查props数据类型,类型不对能快速在console中查看</div><div class="line">2. defaultProps，设置默认props，如果父组件没有特定值</div><div class="line">3. Flow和TypeScript</div><div class="line"></div><div class="line">### ref</div><div class="line">[ref and the dom][2]</div><div class="line">这篇文档写得很详细</div><div class="line">1 尽量少用ref</div><div class="line">2 ref的两种使用方式，一种是直接ref=&apos;&apos;，另一种是通过回调函数的写法，以及其访问方式</div></pre></td></tr></table></figure>
</li>
</ol>
<p>&lt; input ref=’inputElem1’/&gt;<br>&lt; input ref={input =&gt; this.inputElem2 = input} /&gt;</p>
<p><myinput ref="{input" ==""> this.inputElem3 = input} /&gt;<br>``` </myinput></p>
<p>对于直接写的通过<code>this.refs.inputElem1</code> 访问到第一个input<br>对于回调函数直接<code>this.inputElem2</code>来访问，访问到第二个input<br>回调函数的参数<code>input</code>就是对应<code>DOM元素</code>或者当前组件比如<code>MyInput</code>组件<br>如果组件卸载了，访问到的<code>null</code>；<br>官方建议，使用回调函数的写法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇blog主要记录一下&lt;a href=&quot;https://reactjs.org/&quot; target=&quot;_blank&quot; rel=&quot;extern
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>常见问题解决方案合集</title>
    <link href="http://yoursite.com/2017/12/04/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%90%88%E9%9B%86/"/>
    <id>http://yoursite.com/2017/12/04/常见问题解决方案合集/</id>
    <published>2017-12-04T03:26:24.000Z</published>
    <updated>2017-12-04T07:59:21.177Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/262488/pexels-photo-262488.jpeg?w=1260&amp;h=750&amp;auto=compress&amp;cs=tinysrgb" alt="solution"></p>
<p><strong>前端常见问题解决方案</strong><br>这篇blog主要整理工作中遇到的常见的前端问题解决方案</p>
<h4 id="0-输入框密码被浏览器记住，显示黄色背景问题"><a href="#0-输入框密码被浏览器记住，显示黄色背景问题" class="headerlink" title="0 输入框密码被浏览器记住，显示黄色背景问题"></a>0 输入框密码被浏览器记住，显示黄色背景问题</h4><p>浏览器是根据input type=’password’判断保存密码，所以可以将密码input type=’text’,当focus时候设置成password。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input onfocus=&quot;this.type=&apos;password&apos;&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>参考<br><a href="https://www.zhihu.com/question/23529765" target="_blank" rel="external">怎么禁止自动填充浏览器记住密码</a><br><a href="https://stackoverflow.com/questions/31247214/onfocus-and-onblur-does-not-render-in-react" target="_blank" rel="external">onfocus-and-onblur-does-not-render-in-react</a></p>
<a id="more"></a>
<h4 id="1-文本溢出的解决方案"><a href="#1-文本溢出的解决方案" class="headerlink" title="1 文本溢出的解决方案"></a>1 文本溢出的解决方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.text &#123;</div><div class="line">	overflow:hidden;</div><div class="line">	text-overflow: ellipsis;</div><div class="line">	white-space: nowrap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-前端将数据输出并保存的api"><a href="#2-前端将数据输出并保存的api" class="headerlink" title="2 前端将数据输出并保存的api"></a>2 前端将数据输出并保存的api</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// downloadlink 是标签a</div><div class="line">let file = new Blob([data],&#123;type: &apos;text/plain&apos;&#125;);</div><div class="line">downloadlink.href = URL.createObjectURL(file);</div><div class="line">downloadlink.download = name;</div><div class="line">downloadlink.click();</div></pre></td></tr></table></figure>
<p><code>API: new Blob()</code> </p>
<h4 id="3-判断undefined和null"><a href="#3-判断undefined和null" class="headerlink" title="3 判断undefined和null"></a>3 判断<code>undefined</code>和<code>null</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 判断undefined</div><div class="line">typeof value == &apos;undefined&apos;;</div><div class="line">// 判断null</div><div class="line">value === null</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/262488/pexels-photo-262488.jpeg?w=1260&amp;amp;h=750&amp;amp;auto=compress&amp;amp;cs=tinysrgb&quot; alt=&quot;solution&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端常见问题解决方案&lt;/strong&gt;&lt;br&gt;这篇blog主要整理工作中遇到的常见的前端问题解决方案&lt;/p&gt;
&lt;h4 id=&quot;0-输入框密码被浏览器记住，显示黄色背景问题&quot;&gt;&lt;a href=&quot;#0-输入框密码被浏览器记住，显示黄色背景问题&quot; class=&quot;headerlink&quot; title=&quot;0 输入框密码被浏览器记住，显示黄色背景问题&quot;&gt;&lt;/a&gt;0 输入框密码被浏览器记住，显示黄色背景问题&lt;/h4&gt;&lt;p&gt;浏览器是根据input type=’password’判断保存密码，所以可以将密码input type=’text’,当focus时候设置成password。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;input onfocus=&amp;quot;this.type=&amp;apos;password&amp;apos;&amp;quot;/&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;参考&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/23529765&quot;&gt;怎么禁止自动填充浏览器记住密码&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31247214/onfocus-and-onblur-does-not-render-in-react&quot;&gt;onfocus-and-onblur-does-not-render-in-react&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="解决方案" scheme="http://yoursite.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>给hexo博客自定义域名加https</title>
    <link href="http://yoursite.com/2017/12/03/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8A%A0https/"/>
    <id>http://yoursite.com/2017/12/03/给hexo博客自定义域名加https/</id>
    <published>2017-12-03T07:10:14.000Z</published>
    <updated>2017-12-03T07:59:44.083Z</updated>
    
    <content type="html"><![CDATA[<p>给自定义域名加https</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li>看上去更加安全</li>
<li>小绿锁看上去更好看</li>
</ul>
<h3 id="实现方案-cloudflare"><a href="#实现方案-cloudflare" class="headerlink" title="实现方案 cloudflare"></a>实现方案 cloudflare</h3><p>走cloudflare的DNS解析</p>
<ol>
<li>注册cloudflare账号</li>
<li>添加域名<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fm3lp252ssj30rb0ed0ty.jpg" alt="add site"><br>然后一步步走下去就ok了</li>
<li>把你域名原有的DNS修改成cloudflare的<br><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi43n3bs7yj21ig0g4wgj.jpg" alt="modify dns"><br>比如我的是万网<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fm3luk14gij30y90b3gmv.jpg" alt=""></li>
<li>在cloudflare上check 应该很快生效<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fm3lw69h29j30w60dr76l.jpg" alt=""></li>
<li>在cloudflare上配置DNS 之前一直弄不好就是因为这里没有配置好<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fm3lxcpu2rj30t70k20vl.jpg" alt=""><br>按这样配置就ok了，因为是挂在github上的静态博客，所以<code>192.30.252.153</code>指向的github的ip,CNAME的配置，我不是很明白，但就是这样配置就好了。<br>如果你操作完一直不成功可以查看是不是这里配置出问题了。</li>
<li>配置规则，强制走https访问<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fm3m0e6e8dj30s00in41a.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fm3m1st5ymj307n014t8n.jpg" alt=""><br>有个小绿锁还是蛮好看的</li>
</ol>
<h3 id="一些知识"><a href="#一些知识" class="headerlink" title="一些知识"></a>一些知识</h3><p>主要只是就是了解DNS配置时候的A AAAA CNAME等都是啥<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fm3m7e7niqj306109wwep.jpg" alt="dns"><br><code>DNS</code>全称，<code>Domain Name System</code>,域名系统，作为互联网的一项服务,将域名和ip地址映射的一个分布式数据库。通过DNS就可以通过域名，找到对应的物理机ip。<br>上面的A AAAA CNAME都是这套系统的资源记录类型。</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>描述</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>IP地址记录</td>
<td>映射主机域名到IPv4地址</td>
</tr>
<tr>
<td>AAAA</td>
<td>IPv6 IP地址记录</td>
<td>映射主机域名到IPv6地址</td>
</tr>
<tr>
<td>CNAME</td>
<td>规范名称记录</td>
<td>一个主机域名的别名，告诉在哪个地方继续寻找</td>
</tr>
<tr>
<td>MX</td>
<td>电邮交互记录</td>
<td>引导域名到该域名的邮件传输代理(MTA)列表</td>
</tr>
</tbody>
</table>
<p>还有更多的类型参考<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E4%BC%BA%E6%9C%8D%E5%99%A8%E8%A8%98%E9%8C%84%E9%A1%9E%E5%9E%8B%E5%88%97%E8%A1%A8" target="_blank" rel="external">域名服务器记录类型列表</a>，<br><a href="http://www.dirs.cn/" target="_blank" rel="external">域名查询服务</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>应该多去学习一下计算机网络相关的知识 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给自定义域名加https&lt;/p&gt;
&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;看上去更加安全&lt;/li&gt;
&lt;li&gt;小绿锁看上去更好看&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id
    
    </summary>
    
      <category term="https" scheme="http://yoursite.com/categories/https/"/>
    
    
      <category term="dns" scheme="http://yoursite.com/tags/dns/"/>
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>这一年</title>
    <link href="http://yoursite.com/2017/12/02/%E8%BF%99%E4%B8%80%E5%B9%B4/"/>
    <id>http://yoursite.com/2017/12/02/这一年/</id>
    <published>2017-12-02T02:04:43.000Z</published>
    <updated>2017-12-02T02:24:40.198Z</updated>
    
    <content type="html"><![CDATA[<p>感觉今年过的特别快，比以往任何一年都过得快。<br>现在的时间真的是过得越来越快，基本上都是一周一周计算，一个月也就四周，所以一个月也过得相当快。一周过了周二这周基本就快过去了。<br>为什么时间过得越来越快呢？在知乎上看到的别人的解释是有两点：</p>
<ol>
<li>小时候比如十岁的时候，一年的时间，占自己经历的时间10%，等年龄越大，一年的时间占所占有的经历时间越来越少。</li>
<li>工作后的日志，略显枯燥吧，早九晚五，好像每天都在重复，上班下班，一周回忆起来好像没什么东西，每天都是差不多的内容，每周都是差不多的内容。</li>
</ol>
<p>第一点必然是改变不了的，但是第二点吧，生活是自己的，你可以决定生活过的ok不ok,精彩不精彩。一个人就一个人呗，年初办的公园卡，多出去走走，总是好的，至少比总是呆在电脑前打游戏有意思点。</p>
<p>最近读了一本书，「他改变了中国」，恩，是他就是他，一个不敢直呼其名的长者。学习一点长者微不足道的人生经验，一个人的努力啊固然重要，也要考虑历史的进程。一个人的努力比历史进程要重要，历史的进程的种种机遇，没有实力，就算机遇摆着你面前又能怎么样。要不是长者在上海干的那么出色，引起了北京老大哥的注意，也不会一下子就掉到北京去了。<br>现实也是如此的，能力越强的时候，能够选择的机会就多了。</p>
<p>今年定的两个目标，基本也没有实现。<br>一个是学习日语，过二级。三月份的时候报名N3，买了单词书，然后就没有然后了，没有足够的动力吧，因为喜欢看日剧和日语歌曲吧。<br>另一个就是学车，拖了快两年了，上半年的时候想着上半年去把车子学了，因为懒？驾校太远了就拖啊拖啊想着下半年去学，然后一拖就到年末了。</p>
<p>个人blog，也是好久都没有更新了，既然是个人blog就随便写吧，反正也没有备案，开心的不开心的，技术的，生活的，就随便在自己的blog上吐槽吧。</p>
<p>技术上的东西，这一年，也没啥长进吧，React技术栈了解一知半解，D3画图的话只是会用吧，画了一年的拓扑图也没有什么总结，怎么说呢，我发现不止一次发现，知识的总结很重要，前端来说，记忆力也挺重要的，虽然google能找到，比如Array一些api，如果知道的话就不用还要去google了，影响写代码的节奏。</p>
<p>变得焦虑，在同龄人中显得越来越落后带来的焦虑感，如果大家都一样那就没有这种情绪。这种情绪挺负面的，没必要拿别人的人生参考，什么时间点做什么事情，要具有目标性。别人变得优秀，学习他们优秀的地方。</p>
<p>就写到这，去加班了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉今年过的特别快，比以往任何一年都过得快。&lt;br&gt;现在的时间真的是过得越来越快，基本上都是一周一周计算，一个月也就四周，所以一个月也过得相当快。一周过了周二这周基本就快过去了。&lt;br&gt;为什么时间过得越来越快呢？在知乎上看到的别人的解释是有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>js对象和原型对象</title>
    <link href="http://yoursite.com/2017/11/11/js%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2017/11/11/js对象和原型对象/</id>
    <published>2017-11-11T11:37:23.000Z</published>
    <updated>2017-11-16T01:48:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学习了解JavaScript对象的继承机制</p>
<h3 id="JavaScript-Object"><a href="#JavaScript-Object" class="headerlink" title="JavaScript Object"></a>JavaScript Object</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Object是js的基本数据结构的一种，属于引用类型。</p>
<h4 id="对象的创建方法"><a href="#对象的创建方法" class="headerlink" title="对象的创建方法"></a>对象的创建方法</h4><ol>
<li>对象字面量写法</li>
<li>构造函数，通过构造函数来创建对象实例</li>
<li>Object()构造函数</li>
<li>create()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 对象字面量</div><div class="line">let person1 = &#123;name: &apos;jim&apos;&#125;; </div><div class="line">// 构造函数</div><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.greeting = function() &#123;</div><div class="line">        console.log(&apos;hello my name is &apos; + this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let person2 = new Person(&apos;Bob&apos;);</div><div class="line">console.log(person2.name);</div><div class="line">console.log(person2.greeting());</div><div class="line">// Object() 方法</div><div class="line">let person3 = new Object();</div><div class="line">person3.name = &apos;kobe&apos;;</div><div class="line">console.log(person3.name);</div><div class="line">person3 = new Object(&#123;</div><div class="line">    name: &apos;kobe2&apos;,</div><div class="line">    age: 22</div><div class="line">&#125;);</div><div class="line">console.log(person3.name);</div><div class="line">// create() 方法 类似构造函数 </div><div class="line">let person4 = Object.create(person3);</div><div class="line">person4.name = &apos;kobe3&apos;;</div><div class="line">console.log(person4.name,person3.name);</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="对象属性的访问方式"><a href="#对象属性的访问方式" class="headerlink" title="对象属性的访问方式"></a>对象属性的访问方式</h4><ol>
<li>点表示法</li>
<li>中括号表示法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let person = &#123;</div><div class="line">    name: &apos;xiaofei&apos;,</div><div class="line">    age: 20</div><div class="line">&#125;</div><div class="line">console.log(person.name);</div><div class="line">console.log(person[&apos;age&apos;]);</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="proto、-prototype-、prototype"><a href="#proto、-prototype-、prototype" class="headerlink" title="proto、[[prototype]]、prototype"></a><strong>proto</strong>、[[prototype]]、prototype</h3><ol>
<li>JavaScript对象通过<code>原型机制</code>从其他对象<code>继承</code>功能特性</li>
<li>每个对象有一个私有属性<code>[[prototype]]</code>，这个私有属性持有一个连接到另一个称为其<code>prototype</code>对象（原型对象）的链接。</li>
<li><code>__proto__</code>是浏览器对ES语法<code>[[prototype]]</code>的实现api</li>
<li><code>prototype</code>属性指向的对象就是实例对象的原型对象即<code>__proto__</code>所指引的对象</li>
<li>原型链，原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。<br>例1<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fljonn7186j30cf0emdg5.jpg" alt="clipboard.png"></li>
</ol>
<p>例2 通过原型链来检测对象所调用的方法是否存在，存在在哪个原型对象上</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fljonrl5g9j30al0bwjrf.jpg" alt="clipboard.png"><br>person1除了name,age在对象对象中存在外，其他方法都是通过原型链的方法在Object上找到并调用。<br><img src="https://mdn.mozillademos.org/files/13891/MDN-Graphics-person-person-object-2.png" alt="原型链"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;学习了解JavaScript对象的继承机制&lt;/p&gt;
&lt;h3 id=&quot;JavaScript-Object&quot;&gt;&lt;a href=&quot;#JavaScr
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="原型" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>git基础操作</title>
    <link href="http://yoursite.com/2017/08/09/git%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/08/09/git基础操作/</id>
    <published>2017-08-09T14:50:27.000Z</published>
    <updated>2017-11-08T03:09:57.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git三种状态"><a href="#Git三种状态" class="headerlink" title="Git三种状态"></a>Git三种状态</h3><p><strong>—监听事件的状态来做出相应的行为</strong><br>Git项目的三个工作区域: Git仓库，工作目录以及暂存区域<br><img src="https://git-scm.com/book/en/v2/images/areas.png" alt=""></p>
<p>1）Git仓库目录(.git)是用来保存项目元数据和对象数据库的地方，从其他计算机克隆仓库时，拷贝的就是这里的数据。</p>
<p>2）工作目录就是对项目的某个版本独立提取出来的内容，这些内容从G``it仓库的压缩数据库中提取，放在磁盘上提供使用和修改。</p>
<p>3）暂存区域是一个文件，保存下次将要提交的文件列表信息。</p>
<p>基本的Git工作流如下</p>
<pre><code>1. 在工作目录中修改文件
2. 暂存文件，将文件的快照放入暂存区域
3. 提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录
</code></pre><p>暂存区的概念有别于之前用svn，暂存区可以随便放很多文件，commit提交时候不会去理会工作区的文件，如果发现不对劲在暂存区进行修改重置后再提交。<br><a id="more"></a></p>
<h3 id="基础操作指令"><a href="#基础操作指令" class="headerlink" title="基础操作指令"></a>基础操作指令</h3><p>上述工作流中，怎么实际去执行。<br><strong>终端输入指令操作时候，执行注释会提示操作执行的相关信息(做了什么，怎么撤销)注意看</strong><br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fidvr1du2nj30sw0fqgmg.jpg" alt=""></p>
<p>1 add commit<br><code>git add</code> 将文件从工作区提交到暂存区，并track该文件<br><code>git commit</code> 将暂存区的文件提交到Git仓库<br><code>git commit -a</code> 可以将<code>tracked</code>的文件直接提交，省略<code>git add</code>操作</p>
<p>2 更改重置等操作 reset checkout amend<br><code>git reset</code> 将误操作提交到暂存区的文件(没有提交到仓库)撤销回来<br><code>git checkout</code> 已经提交过的文件(在Git仓库)中，撤销改动<br><code>git commit --amend</code> 覆盖上一次的提交 从<code>git log</code>可以查看该功能</p>
<p>3 其他<br><code>git tag</code> 给提交打标签，方便追踪记录重要的提交<br><code>git log</code> 日志功能<br><code>git show</code> 查看<br><code>alias</code> 给常用的命令操作取别名 提高效率<br>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git config --global alias.co checkout</div><div class="line">git config --global alias.br branch</div><div class="line">git config --global alias.ci commit</div><div class="line">git config --global alias.st status</div><div class="line"></div><div class="line">git st // git status</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>Git仓库 工作区 暂存区的状态概念理解</li>
<li>基本的相关指令操作 </li>
<li>暂存区文件的修改 撤销操作</li>
</ol>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93" target="_blank" rel="external">学习来源参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Git三种状态&quot;&gt;&lt;a href=&quot;#Git三种状态&quot; class=&quot;headerlink&quot; title=&quot;Git三种状态&quot;&gt;&lt;/a&gt;Git三种状态&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;—监听事件的状态来做出相应的行为&lt;/strong&gt;&lt;br&gt;Git项目的三个工作区域: Git仓库，工作目录以及暂存区域&lt;br&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/areas.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;1）Git仓库目录(.git)是用来保存项目元数据和对象数据库的地方，从其他计算机克隆仓库时，拷贝的就是这里的数据。&lt;/p&gt;
&lt;p&gt;2）工作目录就是对项目的某个版本独立提取出来的内容，这些内容从G``it仓库的压缩数据库中提取，放在磁盘上提供使用和修改。&lt;/p&gt;
&lt;p&gt;3）暂存区域是一个文件，保存下次将要提交的文件列表信息。&lt;/p&gt;
&lt;p&gt;基本的Git工作流如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 在工作目录中修改文件
2. 暂存文件，将文件的快照放入暂存区域
3. 提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;暂存区的概念有别于之前用svn，暂存区可以随便放很多文件，commit提交时候不会去理会工作区的文件，如果发现不对劲在暂存区进行修改重置后再提交。&lt;br&gt;
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
</feed>
