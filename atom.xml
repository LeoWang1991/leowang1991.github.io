<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lifelover</title>
  
  <subtitle>love life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lifelover.cc/"/>
  <updated>2018-08-08T14:30:27.732Z</updated>
  <id>https://lifelover.cc/</id>
  
  <author>
    <name>骁飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react学习笔记</title>
    <link href="https://lifelover.cc/2018/08/08/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://lifelover.cc/2018/08/08/react学习笔记/</id>
    <published>2018-08-08T03:48:25.000Z</published>
    <updated>2018-08-08T14:30:27.732Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://reactjs.org/docs/getting-started.html" target="_blank" rel="noopener">React官网学习笔记</a></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank" rel="noopener">Pete Hunt: React: Rethinking best practices – JSConf EU 2013</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>受控组件和非受控组件</li><li>diff 算法</li></ol><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;hello world&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>概念：</p><ol><li>jsx是JavaScript语法扩展</li><li>jsx也是对象</li></ol><p>特性：</p><ol><li>jsx可以插入表达式</li><li>属性名驼峰写法 区别于原生HTML tabindex=&gt;tabIndex, class=&gt;className</li><li>防注入攻击XSS，渲染前对特殊字符转码并转为字符串处理</li></ol><a id="more"></a><h3 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h3><p>Rendering Elements</p><ol><li>React元素是不可变的，一旦创建就不能更改其children或者属性。</li><li>An element is like a single frame in a movie: it represents the UI at a center point in time.(特别形象)</li><li>React DOM会比较元素内容先后不同，渲染过程中只更新改变的部分。</li></ol><h3 id="组件和属性"><a href="#组件和属性" class="headerlink" title="组件和属性"></a>组件和属性</h3><p>Components and Props</p><ol><li>概念来说，组件就好像js方法，接受一些参数(props)，输出对应的React元素</li><li>两种创建方式 Functional、Class Components</li><li>React组件名大写开头，区别于DOM原生标签</li><li>所有组件都必须像纯函数那样使用props</li></ol><h3 id="State和Lifecycle"><a href="#State和Lifecycle" class="headerlink" title="State和Lifecycle"></a>State和Lifecycle</h3><ol><li>State类似props，但是state是组件私有和控制的。</li><li>State 不能直接改变 如this.state.comment = ‘hello’;</li><li>this.props this.state更新都是异步的，性能优化合并批处理,<br>不要依赖其值做下一次计算<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">   counter: this.state.counter + this.props.increment</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>通过setState第二种形式<code>接受函数</code>，而不是<code>接受对象</code>来处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState, props) =&gt; &#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ol><li><a href="https://doc.react-china.org/docs/state-and-lifecycle.html#%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E5%90%88%E5%B9%B6" target="_blank" rel="noopener">状态更新合并</a>， 调用<code>setState</code>，React将提供的对象合并到<br>当前状态。状态更新合并是浅合并。</li><li>数据自顶向下流动，通过props传递到组件</li></ol><h3 id="Handling-Events事件处理"><a href="#Handling-Events事件处理" class="headerlink" title="Handling Events事件处理"></a>Handling Events事件处理</h3><p>与DOM事件不同的地方<br>1 React事件书写驼峰写法<br>2 如果是jsx写法 需要传入函数而不是字符串来表示<br>传统HTML<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&apos;activeLasers()&apos;&gt;Active Laser&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><p>React写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&#123;activeLasers&#125;&gt;Active Laser&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><p>3 html中事件采用<code>return false;</code>来阻止默认行为，在React中<br>采用<code>e.preventDefault()</code>来处理<br>4 几种事件绑定方式</p><ul><li>在构造函数中使用bind绑定this</li><li>在调用时候使用bind绑定this</li><li>在调用时候使用箭头函数</li><li>使用属性初始化器语法<br>参考<a href="https://segmentfault.com/a/1190000011317515" target="_blank" rel="noopener">React事件绑定几种方式对比</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Toggle extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state = &#123;isToggleOn: true&#125;;</span><br><span class="line">      // 方式1 在构造函数中使用bind绑定this</span><br><span class="line">      this.handleClick = this.handleClick.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      this.setState(prevState =&gt; (&#123;</span><br><span class="line">        isToggleOn: !prevState.isToggleOn</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    handleClick2() &#123;</span><br><span class="line">        console.log(&apos;handleClick2&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方式4： 属性初始化器语法</span><br><span class="line">    handleClick4 = () =&gt; &#123;</span><br><span class="line">        console.log(&apos;handleClick3&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">                    click</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">                &#123;/*方式2 在调用的时候采用bind绑定this*/&#125;</span><br><span class="line">                &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt; </span><br><span class="line">                    click2</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">                &#123;/*方式3 在调用时候采用箭头函数 会有性能问题不推荐*/&#125;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; this.handleClick3()&#125;&gt;</span><br><span class="line">                    click3</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.handleClick4&#125;&gt;</span><br><span class="line">                    click4</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        </span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Toggle /&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><ol><li>jsx中使用条件表达式 if…else 三目表达式来选择性渲染元素</li><li>通过<code>return null;</code>阻止组件渲染，不影响组件生命周期</li></ol><h3 id="列表和Keys"><a href="#列表和Keys" class="headerlink" title="列表和Keys"></a>列表和Keys</h3><p>遍历渲染组件时候，需要加key，帮助React标识组件改变 增加删除等。<br>diff算法了解一下</p><h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><p>共享组件的数据，推荐将这些状态提升到最近的父组件管理。<br>在组件编写时候需要去考虑如何拆分组件进行编写。</p><h3 id="组合和继承"><a href="#组合和继承" class="headerlink" title="组合和继承"></a>组合和继承</h3><ol><li>组件可以接受任意元素包括数据类型 React元素 或者函数</li><li>组件之间复用UI无关的功能(通用方法)，建议提取到单独JavaScript模块中。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React官网学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;扩展&quot;&gt;&lt;a href=&quot;#扩展&quot; class=&quot;headerlink&quot; title=&quot;扩展&quot;&gt;&lt;/a&gt;扩展&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=x7cQ3mrcKaY&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pete Hunt: React: Rethinking best practices – JSConf EU 2013&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;受控组件和非受控组件&lt;/li&gt;
&lt;li&gt;diff 算法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;JSX&quot;&gt;&lt;a href=&quot;#JSX&quot; class=&quot;headerlink&quot; title=&quot;JSX&quot;&gt;&lt;/a&gt;JSX&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const element = &amp;lt;h1&amp;gt;hello world&amp;lt;/h1&amp;gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;jsx是JavaScript语法扩展&lt;/li&gt;
&lt;li&gt;jsx也是对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;jsx可以插入表达式&lt;/li&gt;
&lt;li&gt;属性名驼峰写法 区别于原生HTML tabindex=&amp;gt;tabIndex, class=&amp;gt;className&lt;/li&gt;
&lt;li&gt;防注入攻击XSS，渲染前对特殊字符转码并转为字符串处理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="前端" scheme="https://lifelover.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="https://lifelover.cc/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>javascript dom编程艺术 笔记</title>
    <link href="https://lifelover.cc/2018/08/05/javascript-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E7%AC%94%E8%AE%B0/"/>
    <id>https://lifelover.cc/2018/08/05/javascript-dom编程艺术-笔记/</id>
    <published>2018-08-05T05:54:15.000Z</published>
    <updated>2018-08-05T05:56:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="了解的知识点"><a href="#了解的知识点" class="headerlink" title="了解的知识点"></a>了解的知识点</h3><ol><li>DOM概念</li><li>JavaScript相关原生api</li></ol><h3 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftv4mk3l2ij30tw19xq8a.jpg" alt=""></p><a id="more"></a><h3 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h3><h4 id="XHTML-HTML"><a href="#XHTML-HTML" class="headerlink" title="XHTML HTML"></a>XHTML HTML</h4><p>XML给文档加标记，方便存储传输分享数据，XML的语法严格。<br>XHTML就是用XML语法形式来写HTML<br>XHTML语法要求有</p><ol><li>必须包含文件头声明&lt;!DOCTYPE&gt;</li><li>所有元素名小写</li><li>所有空元素必须关闭</li><li>所有属性值/名必须加引号</li></ol><h3 id="渐进增强和平稳退化"><a href="#渐进增强和平稳退化" class="headerlink" title="渐进增强和平稳退化"></a>渐进增强和平稳退化</h3><p>渐进增强 progressive enhancement<br>原则就一点，编写DOM时，考虑网站不支持js，css时候核心内容也能展示给用户。<br>所以采用<code>渐进增强</code>原则来编写代码时候，不要通过JavaScript来添加一些重要内容，如果网站不支持js。<br>总是应该从最核心的地方，即从内容开始，根据内容使用标记，实现良好的结构；然后再逐步加强这些内容，<br>加强的工作既可以通过css改进呈现效果，也可以通过DOM添加各种行为。<br>平稳退化： 渐进增强的实现必然支持平稳退化，如上，按渐进增强的原则去充实内容，就算去掉css或者DOM<br>支持依然可以访问到核心内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;了解的知识点&quot;&gt;&lt;a href=&quot;#了解的知识点&quot; class=&quot;headerlink&quot; title=&quot;了解的知识点&quot;&gt;&lt;/a&gt;了解的知识点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;DOM概念&lt;/li&gt;
&lt;li&gt;JavaScript相关原生api&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;整理&quot;&gt;&lt;a href=&quot;#整理&quot; class=&quot;headerlink&quot; title=&quot;整理&quot;&gt;&lt;/a&gt;整理&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftv4mk3l2ij30tw19xq8a.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://lifelover.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://lifelover.cc/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>hello world</title>
    <link href="https://lifelover.cc/2018/07/27/hello-world/"/>
    <id>https://lifelover.cc/2018/07/27/hello-world/</id>
    <published>2018-07-27T06:23:53.000Z</published>
    <updated>2018-07-27T06:24:12.306Z</updated>
    
    <content type="html"><![CDATA[<p>console.log(‘hello world’);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;console.log(‘hello world’);&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node卸载与重装</title>
    <link href="https://lifelover.cc/2018/04/08/node%E5%8D%B8%E8%BD%BD%E4%B8%8E%E9%87%8D%E8%A3%85/"/>
    <id>https://lifelover.cc/2018/04/08/node卸载与重装/</id>
    <published>2018-04-08T12:47:21.000Z</published>
    <updated>2018-04-08T14:15:49.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为不知道怎么回事 node 和 npm 安装时候总是会出现一些莫名其妙的问题,于是索性打算卸了重装，顺便学习一下遇到的一些问题。</p><ol><li>homebrew</li><li>symlink 软链接是啥</li><li>chmod 权限指令 改变权限</li><li>macOS /usr/bin 系统目录 分别放了什么内容</li></ol><h3 id="node-卸载"><a href="#node-卸载" class="headerlink" title="node 卸载"></a>node 卸载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /usr/local/lib/node_modules</span><br><span class="line">sudo rm -rf ~/.npm</span><br><span class="line">brew uninstall --force node</span><br><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>总之就是把改删的都删除了就行了<br>参考<a href="https://stackoverflow.com/questions/33870520/npm-install-cannot-find-module-semver" target="_blank" rel="noopener">stackoverflow-uninstall node</a></p><h3 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h3><p>可以去官网下载pkg安装，推荐使用<code>brew install node</code>安装<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fq5js4ltmyj30d50cojtx.jpg" alt=""></p><p>不清楚为什么这样 google后的解决方案是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 776 /usr/local/lib</span><br><span class="line">brew link --overwrite node</span><br><span class="line">//Outputs: Linking /usr/local/Cellar/node/9.6.1... 49 symlinks created</span><br><span class="line">sudo chmod 755 /usr/local/lib</span><br></pre></td></tr></table></figure></p><p>应该是权限问题<br>参考<a href="https://stackoverflow.com/questions/35249204/node-already-installed-its-just-not-linked#" target="_blank" rel="noopener">node already installed its just node linked</a>最下面的回答</p><p>至此，卸载与安装完成</p><h3 id="npm-config-配置解释"><a href="#npm-config-配置解释" class="headerlink" title="npm config 配置解释"></a>npm config 配置解释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; cli configs</span><br><span class="line">metrics-registry = &quot;https://registry.npm.taobao.org/&quot;</span><br><span class="line">scope = &quot;&quot;</span><br><span class="line">user-agent = &quot;npm/5.6.0 node/v9.11.1 darwin x64&quot;</span><br><span class="line"></span><br><span class="line">; userconfig /Users/jingxiao/.npmrc</span><br><span class="line">config = &quot;&quot;</span><br><span class="line">cwd = &quot;/Users/jingxiao&quot;</span><br><span class="line">prefix = &quot;/usr/local&quot;</span><br><span class="line">registry = &quot;https://registry.npm.taobao.org/&quot;</span><br><span class="line"></span><br><span class="line">; builtin config undefined</span><br><span class="line">prefix = &quot;/usr/local&quot;</span><br><span class="line"></span><br><span class="line">; node bin location = /usr/local/Cellar/node/9.11.1/bin/node</span><br><span class="line">; cwd = /Users/jingxiao</span><br><span class="line">; HOME = /Users/jingxiao</span><br><span class="line">; &quot;npm config ls -l&quot; to show all defaults.</span><br></pre></td></tr></table></figure><p><code>metrics-registry</code> npm源地址，默认应该是指向npm的地址，我也没有去设置taobao源居然自动换成了淘宝源。<br><code>scope</code> 域名，比如个人或者公司私有的仓库，不用担心重名问题了 @somescope/somepackagename<br><code>user-agent</code> 用户代理，比如浏览器的话就是chrome firefox之类的，n这里就是node环境了<br><code>prefix</code> npm全局路径<br><code>cwd</code> process.cwd() current working directory. 当前工作目录</p><h3 id="npm-安装权限问题"><a href="#npm-安装权限问题" class="headerlink" title="npm 安装权限问题"></a>npm 安装权限问题</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fq5krp1e5tj30ps0dq0w3.jpg" alt=""></p><p>全局安装webpack并没有问题，安装webpack-cli指令时候会有权限问题<br>解决权限问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;因为不知道怎么回事 node 和 npm 安装时候总是会出现一些莫名其妙的问题,于是索性打算卸了重装，顺便学习一下遇到的一些问题。&lt;/p&gt;

      
    
    </summary>
    
      <category term="前端" scheme="https://lifelover.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://lifelover.cc/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>给hexo博客自定义域名加https</title>
    <link href="https://lifelover.cc/2017/12/03/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8A%A0https/"/>
    <id>https://lifelover.cc/2017/12/03/给hexo博客自定义域名加https/</id>
    <published>2017-12-03T07:10:14.000Z</published>
    <updated>2018-04-12T08:18:56.607Z</updated>
    
    <content type="html"><![CDATA[<p>给自定义域名加https</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>看上去更加安全</li><li>小绿锁看上去更好看</li></ul><h3 id="实现方案-cloudflare"><a href="#实现方案-cloudflare" class="headerlink" title="实现方案 cloudflare"></a>实现方案 cloudflare</h3><p>走cloudflare的DNS解析</p><ol><li>注册cloudflare账号</li><li>添加域名<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fm3lp252ssj30rb0ed0ty.jpg" alt="add site"><br>然后一步步走下去就ok了</li><li>把你域名原有的DNS修改成cloudflare的<br><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi43n3bs7yj21ig0g4wgj.jpg" alt="modify dns"><br>比如我的是万网<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fm3luk14gij30y90b3gmv.jpg" alt=""></li><li>在cloudflare上check 应该很快生效<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fm3lw69h29j30w60dr76l.jpg" alt=""></li><li>在cloudflare上配置DNS 之前一直弄不好就是因为这里没有配置好<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fm3lxcpu2rj30t70k20vl.jpg" alt=""><br>按这样配置就ok了，因为是挂在github上的静态博客，所以<code>192.30.252.153</code>指向的github的ip,CNAME的配置，我不是很明白，但就是这样配置就好了。<br>如果你操作完一直不成功可以查看是不是这里配置出问题了。</li><li>配置规则，强制走https访问<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fm3m0e6e8dj30s00in41a.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fm3m1st5ymj307n014t8n.jpg" alt=""><br>有个小绿锁还是蛮好看的</li></ol><h3 id="一些知识"><a href="#一些知识" class="headerlink" title="一些知识"></a>一些知识</h3><p>主要只是就是了解DNS配置时候的A AAAA CNAME等都是啥<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fm3m7e7niqj306109wwep.jpg" alt="dns"><br><code>DNS</code>全称，<code>Domain Name System</code>,域名系统，作为互联网的一项服务,将域名和ip地址映射的一个分布式数据库。通过DNS就可以通过域名，找到对应的物理机ip。<br>上面的A AAAA CNAME都是这套系统的资源记录类型。</p><table><thead><tr><th>代码</th><th>描述</th><th>功能</th></tr></thead><tbody><tr><td>A</td><td>IP地址记录</td><td>映射主机域名到IPv4地址</td></tr><tr><td>AAAA</td><td>IPv6 IP地址记录</td><td>映射主机域名到IPv6地址</td></tr><tr><td>CNAME</td><td>规范名称记录</td><td>一个主机域名的别名，告诉在哪个地方继续寻找</td></tr><tr><td>MX</td><td>电邮交互记录</td><td>引导域名到该域名的邮件传输代理(MTA)列表</td></tr></tbody></table><p>还有更多的类型参考<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E4%BC%BA%E6%9C%8D%E5%99%A8%E8%A8%98%E9%8C%84%E9%A1%9E%E5%9E%8B%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">域名服务器记录类型列表</a>，<br><a href="http://www.dirs.cn/" target="_blank" rel="noopener">域名查询服务</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>应该多去学习一下计算机网络相关的知识 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给自定义域名加https&lt;/p&gt;
&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;看上去更加安全&lt;/li&gt;
&lt;li&gt;小绿锁看上去更好看&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id
      
    
    </summary>
    
      <category term="https" scheme="https://lifelover.cc/categories/https/"/>
    
    
      <category term="dns" scheme="https://lifelover.cc/tags/dns/"/>
    
      <category term="http" scheme="https://lifelover.cc/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>js对象和原型对象</title>
    <link href="https://lifelover.cc/2017/11/11/js%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>https://lifelover.cc/2017/11/11/js对象和原型对象/</id>
    <published>2017-11-11T11:37:23.000Z</published>
    <updated>2017-11-16T01:48:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学习了解JavaScript对象的继承机制</p><h3 id="JavaScript-Object"><a href="#JavaScript-Object" class="headerlink" title="JavaScript Object"></a>JavaScript Object</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Object是js的基本数据结构的一种，属于引用类型。</p><h4 id="对象的创建方法"><a href="#对象的创建方法" class="headerlink" title="对象的创建方法"></a>对象的创建方法</h4><ol><li>对象字面量写法</li><li>构造函数，通过构造函数来创建对象实例</li><li>Object()构造函数</li><li>create()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 对象字面量</span><br><span class="line">let person1 = &#123;name: &apos;jim&apos;&#125;; </span><br><span class="line">// 构造函数</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.greeting = function() &#123;</span><br><span class="line">        console.log(&apos;hello my name is &apos; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let person2 = new Person(&apos;Bob&apos;);</span><br><span class="line">console.log(person2.name);</span><br><span class="line">console.log(person2.greeting());</span><br><span class="line">// Object() 方法</span><br><span class="line">let person3 = new Object();</span><br><span class="line">person3.name = &apos;kobe&apos;;</span><br><span class="line">console.log(person3.name);</span><br><span class="line">person3 = new Object(&#123;</span><br><span class="line">    name: &apos;kobe2&apos;,</span><br><span class="line">    age: 22</span><br><span class="line">&#125;);</span><br><span class="line">console.log(person3.name);</span><br><span class="line">// create() 方法 类似构造函数 </span><br><span class="line">let person4 = Object.create(person3);</span><br><span class="line">person4.name = &apos;kobe3&apos;;</span><br><span class="line">console.log(person4.name,person3.name);</span><br></pre></td></tr></table></figure></li></ol><h4 id="对象属性的访问方式"><a href="#对象属性的访问方式" class="headerlink" title="对象属性的访问方式"></a>对象属性的访问方式</h4><ol><li>点表示法</li><li>中括号表示法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    name: &apos;xiaofei&apos;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line">console.log(person.name);</span><br><span class="line">console.log(person[&apos;age&apos;]);</span><br></pre></td></tr></table></figure></li></ol><h3 id="proto、-prototype-、prototype"><a href="#proto、-prototype-、prototype" class="headerlink" title="proto、[[prototype]]、prototype"></a><strong>proto</strong>、[[prototype]]、prototype</h3><ol><li>JavaScript对象通过<code>原型机制</code>从其他对象<code>继承</code>功能特性</li><li>每个对象有一个私有属性<code>[[prototype]]</code>，这个私有属性持有一个连接到另一个称为其<code>prototype</code>对象（原型对象）的链接。</li><li><code>__proto__</code>是浏览器对ES语法<code>[[prototype]]</code>的实现api</li><li><code>prototype</code>属性指向的对象就是实例对象的原型对象即<code>__proto__</code>所指引的对象</li><li>原型链，原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。<br>例1<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fljonn7186j30cf0emdg5.jpg" alt="clipboard.png"></li></ol><p>例2 通过原型链来检测对象所调用的方法是否存在，存在在哪个原型对象上</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fljonrl5g9j30al0bwjrf.jpg" alt="clipboard.png"><br>person1除了name,age在对象对象中存在外，其他方法都是通过原型链的方法在Object上找到并调用。<br><img src="https://mdn.mozillademos.org/files/13891/MDN-Graphics-person-person-object-2.png" alt="原型链"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;学习了解JavaScript对象的继承机制&lt;/p&gt;
&lt;h3 id=&quot;JavaScript-Object&quot;&gt;&lt;a href=&quot;#JavaScr
      
    
    </summary>
    
      <category term="前端" scheme="https://lifelover.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="原型" scheme="https://lifelover.cc/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="JavaScript" scheme="https://lifelover.cc/tags/JavaScript/"/>
    
  </entry>
  
</feed>
