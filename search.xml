<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端代码规范整理]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 整理下前端代码规范 主要有如下几块内容的整理 JavaScript less规范 React 参考 Airbnb JavaScript Style Guide 编写可读代码的实践 Auto-Frontend-End Coding Guidelines Less 编码规范 Netease Css规范 JavaScript(ES6) 代码更优写法 所有赋值应该使用const，如果需要对变量重新赋值则使用let，避免使用var 创建对象时候，使用对象方法简写，属性值缩写 1234567891011121314151617181920212223242526272829// badconst atom = &#123; value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;;const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; lukeSkywalker: lukeSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker,&#125;; 使用对象解构来获取单个或者多个属性值 123456789101112131415161718// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// goodfunction getFullName(user) &#123; const &#123; firstName, lastName &#125; = user; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; 使用数组解构 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 多个返回值使用对象解构而不是数组解构(对象解构不用考虑顺序) 1234567891011121314151617// badfunction processInput(input) &#123; // then a miracle occurs return [left, right, top, bottom];&#125;// the caller needs to think about the order of return dataconst [left, __, top] = processInput(input);// goodfunction processInput(input) &#123; // then a miracle occurs return &#123; left, right, top, bottom &#125;;&#125;// the caller selects only the data they needconst &#123; left, top &#125; = processInput(input); 使用字符串模板来进行拼接可编程字符串 使用箭头函数来代替函数表达式 如果函数体由一个没有副作用的表达式语句组成，删除大括号和return。 1234567891011121314151617181920212223242526272829303132333435363738// bad[1, 2, 3].map(number =&gt; &#123; const nextNumber = number + 1; `A string containing the $&#123;nextNumber&#125;.`;&#125;);// good[1, 2, 3].map(number =&gt; `A string containing the $&#123;number&#125;.`);// good[1, 2, 3].map((number) =&gt; &#123; const nextNumber = number + 1; return `A string containing the $&#123;nextNumber&#125;.`;&#125;);// good[1, 2, 3].map((number, index) =&gt; (&#123; [index]: number&#125;));// 表达式有副作用就不要用隐式returnfunction foo(callback) &#123; const val = callback(); if (val === true) &#123; // Do something if callback returns true &#125;&#125;let bool = false;// bad// 这种情况会return bool = true, 不好foo(() =&gt; bool = true);// goodfoo(() =&gt; &#123; bool = true;&#125;); 用(import/export) 模块而不是无标准的模块系统。 1234567891011// badconst AirbnbStyleGuide = require('./AirbnbStyleGuide');module.exports = AirbnbStyleGuide.es6;// okimport AirbnbStyleGuide from './AirbnbStyleGuide';export default AirbnbStyleGuide.es6;// bestimport &#123; es6 &#125; from './AirbnbStyleGuide';export default es6; 访问属性时候用点符号.，获取属性时候用中括号[] 12345678910111213const person = &#123; name: 'xiaofei', age: 20&#125;const name = person.name;const STATUS = &#123; success: '通过', error: '错误', failed: '失败'&#125;;// 一般用来处理动态返回值的映射关系 当属性值是个变量const status = STATUS[response.status]; 使用===代替==,!==代替!= 更加严谨 避免不需要的三元表达式 123456789// badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true;// goodconst foo = a || b;const bar = !!c;const baz = !c; 如果 if 语句中总是需要用 return 返回， 那后续的 else 就不需要写了 1234567891011121314151617// badfunction foo() &#123; if (x) &#123; return x; &#125; else &#123; return y; &#125;&#125;// goodfunction foo() &#123; if (x) &#123; return x; &#125; return y;&#125; 布尔值最佳写法 12345678910const age = 0;// badconst hasAge = new Boolean(age);// goodconst hasAge = Boolean(age);// bestconst hasAge = !!age; 代码更优格式 多行import应该缩进，就像多行数组和对象字面量。(代码可读性更高) 1234567891011// badimport &#123;longNameA, longNameB, longNameC, longNameD, longNameE&#125; from 'path';// goodimport &#123; longNameA, longNameB, longNameC, longNameD, longNameE,&#125; from 'path'; const放一起，let放一起 123456789101112131415161718// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; 当控制语句(if, while 等)太长或者超过最大长度限制的时候， 把每一个(组)判断条件放在单独一行里。 逻辑操作符放在行首。(或者把判断条件写到一个变量) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// badif ((foo === 123 || bar === 'abc') &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) &#123; thing1();&#125;// badif (foo === 123 &amp;&amp; bar === 'abc') &#123; thing1();&#125;// badif (foo === 123 &amp;&amp; bar === 'abc') &#123; thing1();&#125;// badif ( foo === 123 &amp;&amp; bar === 'abc') &#123; thing1();&#125;// goodif ( foo === 123 &amp;&amp; bar === 'abc') &#123; thing1();&#125;// goodif ( (foo === 123 || bar === 'abc') &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) &#123; thing1();&#125;// goodif (foo === 123 &amp;&amp; bar === 'abc') &#123; thing1();&#125; 注释 多行注释用 /** ... */ 单行注释用//，将单行注释放在被注释区域上面。如果注释不是在第一行，那么注释前面就空一行 所有注释开头空一个，方便阅读 在你的注释前使用FIXME或TODO等前缀，帮助自己或者其他开发快速定位问题或者需求 当出现长的方法链（&gt;2个）时用缩进 123456789101112131415161718// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount(); 关于命名 名字可描述，比如获取人才数据getTalentData 用小驼峰式命名(首字母小写)你的对象、函数、实例 用大驼峰式(首字母大写)命名类 不要用前置或后置下划线(前置_一般表示私有变量) export default导出模块A，则这个文件名也叫A.*， import 时候的参数也叫A；(统一，方便自己快读定位到代码) 简称和缩写应该全部大写或全部小写。(单词长也不要简写，除非是大家都常用的简写) 静态变量全部大写命名比如const STATUS = {...} 对于很多文件都使用的变量中，可以写到一份文件如constant.js然后在其他文件中import使用 Css/less规范 CSS的命名规则 统一处理：建议在这个位置统一调用背景图（这里指多个布局或模块或元件共用的图）和清除浮动（这里指通用性较高的布局、模块、元件内的清除）等统一设置处理的样式！ 布局（grid）（.g-）：将页面分割为几个大块，通常有头部、主体、主栏、侧栏、尾部等！ 模块（module）（.m-）：通常是一个语义化的可以重复使用的较大的整体！比如导航、登录、注册、各种列表、评论、搜索等！ 元件（unit）（.u-）：通常是一个不可再分的较为小巧的个体，通常被重复用于各种模块中！比如按钮、输入框、loading、图标等！ 功能（function）（.f-）：为方便一些常用样式的使用，我们将这些使用率较高的样式剥离出来，按需使用，通常这些选择器具有固定样式表现，比如清除浮动等！不可滥用！ 皮肤（skin）（.s-）：如果你需要把皮肤型的样式抽离出来，通常为文字色、背景色（图）、边框色等，非换肤型网站通常只提取文字色！非换肤型网站不可滥用此类！ 状态（.z-）：为状态类样式加入前缀，统一标识，方便识别，她只能组合使用或作为后代出现（.u-ipt.z-dis{}，.m-list li.z-sel{}），具体详见命名规则的扩展相关项。 功能类和皮肤类样式为表现化的样式，请不要滥用！以上顺序可以按需求适当调整。 格式 使用 2 个空格作为缩进。 类名建议使用破折号代替驼峰法。 在一个规则声明中应用了多个选择器时，每个选择器独占一行。 在规则声明的左大括号 { 前加上一个空格。 在属性的冒号 : 后面加上一个空格，前面不加空格。 规则声明的右大括号 } 独占一行。 规则声明之间用空行分隔开。 Less 代码必须按如下形式按顺序组织： @import 变量声明 样式声明 123456789// ✓@import "est/all.less";@default-text-color: #333;.page &#123; width: 960px; margin: 0 auto;&#125; @import 语句引用的文件必须写在一对引号内，.less 后缀不得省略（与引入 CSS 文件时的路径格式一致）。引号使用 ' 和 &quot; 均可，但在同一项目内必须统一。 1234567// ✗@import 'est/all';@import "my/mixins.less";// ✓@import "est/all.less";@import "my/mixins.less"; 当多个选择器共享一个声明块时，每个选择器声明必须独占一行。 1234567891011// ✗h1, h2, h3 &#123; font-weight: 700;&#125;// ✓h1,h2,h3 &#123; font-weight: 700;&#125; 单行注释 尽量使用//方式 React 使用ES6的组件声明写法 123456789101112131415// badconst Listing = React.createClass(&#123; // ... render() &#123; return &lt;div&gt;&#123;this.state.hello&#125;&lt;/div&gt;; &#125;&#125;);// goodclass Listing extends React.Component &#123; // ... render() &#123; return &lt;div&gt;&#123;this.state.hello&#125;&lt;/div&gt;; &#125;&#125; 对于无状态组件，使用函数写法 12345678910111213141516// badclass Listing extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.hello&#125;&lt;/div&gt;; &#125;&#125;// bad (relying on function name inference is discouraged)const Listing = (&#123; hello &#125;) =&gt; ( &lt;div&gt;&#123;hello&#125;&lt;/div&gt;);// goodfunction Listing(&#123; hello &#125;) &#123; return &lt;div&gt;&#123;hello&#125;&lt;/div&gt;;&#125; 命名规范 文件名以.jsx格式 文件名用大驼峰写法(首字母大写) 组件名大写，实例化则用驼峰命名(首字母小写) 1234567891011// badimport reservationCard from './ReservationCard';// goodimport ReservationCard from './ReservationCard';// badconst ReservationItem = &lt;ReservationCard /&gt;;// goodconst reservationItem = &lt;ReservationCard /&gt;; 文件名与组件名一致，如果是目录下的根组件则使用index.jsx来作为组件的文件名，引用时直接写目录名即可 12345678// badimport Footer from './Footer/Footer';// badimport Footer from './Footer/index';// goodimport Footer from './Footer'; 对齐风格(可读性) 123456789101112131415161718192021222324252627282930313233343536373839// bad&lt;Foo superLongParam="bar" anotherSuperLongParam="baz" /&gt;// good&lt;Foo superLongParam="bar" anotherSuperLongParam="baz"/&gt;// if props fit in one line then keep it on the same line&lt;Foo bar="bar" /&gt;// children get indented normally&lt;Foo superLongParam="bar" anotherSuperLongParam="baz"&gt; &lt;Quux /&gt;&lt;/Foo&gt;// bad&#123;showButton &amp;&amp; &lt;Button /&gt;&#125;// bad&#123; showButton &amp;&amp; &lt;Button /&gt;&#125;// good&#123;showButton &amp;&amp; ( &lt;Button /&gt;)&#125;// good&#123;showButton &amp;&amp; &lt;Button /&gt;&#125; 使用refs的回调写法 123456789// bad&lt;Foo ref="myRef"/&gt;// good&lt;Foo ref=&#123;(ref) =&gt; &#123; this.myRef = ref; &#125;&#125;/&gt; 如果属性值为 true, 可以直接省略 123456789101112// bad&lt;Foo hidden=&#123;true&#125;/&gt;// good&lt;Foo hidden/&gt;// good&lt;Foo hidden /&gt; 对于class extends React.Component方法书写顺序建议 (可选) static methods constructor getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers 比如onClickSubmit() 或者 onChangeDescription() getter methods for render 比如 getSelectReason() 或者 getFooterContent() optional render methods 比如 renderNavigation() 或者 renderProfilePicture() render]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的js 笔记]]></title>
    <url>%2F2019%2F04%2F15%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 你不知道的js相关学习笔记 笔记 1 编译原理 2 js引擎 编译器 作用域 3 LHS和RHS查询 知识点 1 作用域是一套规则，用于确定在何处以及如何查找变量(标识符)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式学习笔记]]></title>
    <url>%2F2019%2F04%2F13%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 之前写代码遇到个问题，就是[&quot;admin&quot;]提取其中的字符串admin因为不会写正则只能通过replace('[&quot;','').replace('&quot;]','')操作，感觉很笨拙，通过正则去应该是更好的方法。 本文主要了解 什么是正则表达式 基本语法规则 正则表达式是什么 个人理解就是匹配文本的规则吧，了解这个规则怎么去写对文本处理真的太有帮助了。 基础语法 元字符 元字符是一些特定辅助精准匹配的特定字符 代码 说明 . 匹配除换行符以为的任何字符 \w 匹配字母 数字 下划线 汉字 \s 匹配任意空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 对于特殊字符需要通过\来转义，比如匹配.那么需要使用\. 重复 代码 说明 * 重复0次或更多次 + 重复1次或更多次 ？ 重复0次或1次 {n} 重复n次 {n,} 重复n或更多次 {n,m} 重复n到m次 设置匹配字符集 通过[]来设定匹配字符集 如[0-9]就相当于\d 分组 对单个字符来说，通过0{n}来设置匹配次数，但是对于字符串而言的话，通过分组来解决(\d{1,3}\.){3}\d{1,3}匹配ip。 反义 代码/语法 说明 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 以上差不多就能日常使用了 其他高级用法参考 正则表达式30分钟入门教程 总结 回到上面之前的问题 从[&quot;admin&quot;]中提取admin就可以写 1'["amdin"]'.replace(/\[\"|\"\]/g,'')]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react ssr学习]]></title>
    <url>%2F2019%2F04%2F04%2Freact-ssr%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言 了解ssr 带着问题 SSR是什么东西 同构有是什么 SSR使用场景，解决什么问题 那么怎么使用ssr 有没有现成的优秀的轮子直接用 看看轮子 参考文档 React中同构原理(SSR)脉络梳理 服务端渲染vs 客户端渲染 笔记 SSR是什么 server-side rendering，字面意思就是服务端渲染，相对客户端渲染csr(client-side-rending)。 具体点说呢？ 客户端渲染的话，浏览器加载页面，服务端返回html文件但是没有内容展示，然后去加载执行html文件中的js去请求数据填充数据完成页面的交互事件绑定。 服务端渲染的话，返回html文件之前就把所有的数据填充好然后返回，浏览器只负责解析html就行了。 最后都是一样，有数据地展示页面。 SSR使用场景 seo，爬虫看不到完整源码 首屏加载慢，这个有体会。在 CSR 的页面渲染流程中，首先要加载 HTML 文件，之后要下载页面所需的 JavaScript 文件，然后 JavaScript 文件渲染生成页面。在这个渲染过程中至少涉及到两个 HTTP 请求周期，所以会有一定的耗时，这也是为什么大家在低网速下访问普通的 React 或者 Vue 应用时，初始页面会有出现白屏的原因。 缺点，第一篇参考文中有指出，本来简单的步骤因为ssr变得繁琐，项目可维护性差。 同构 同构：同构这个概念存在于 Vue，React 这些新型的前端框架中，同构实际上是客户端渲染和服务器端渲染的一个整合。我们把页面的展示内容和交互写在一起，让代码执行两次。在服务器端执行一次，用于实现服务器端渲染，在客户端再执行一次，用于接管页面交互。 实现原理 vitual-dom的存在]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F04%2Fnpm%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言 npm操作指令笔记 查看 1 查看已经安装的包文件 版本号 查看所有 npm list -g --depth=0(depth=0去掉其他依赖项) 查看特定npm view xxx version -g 查看过期的 npm outdated -g --depth=0 2 查看全局包安装路径 npm config get prefix,设置的话则 npm config set prefix '']]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F27%2F%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 我差不多都忘了，我还有台腾讯云服务器，到2023年到期。我寻思着也不能这么浪费吧。所以花时间折腾下，做些记录咯。 命令行指南 yum: yellow dog updater 安装各种东西 zsh(ys主题) https://www.jianshu.com/p/556ff130fc65]]></content>
  </entry>
  <entry>
    <title><![CDATA[git操作指南]]></title>
    <url>%2F2019%2F03%2F26%2Fgit%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言 了解掌握基础的git操作 备忘录 操作 新建本地分支 推送到远程仓库 12git checkout -b feature-branch //创建并切换到分支feature-branch $ git push origin feature-branch:feature-branch //推送本地的feature-branch(冒号前面的)分支到远程origin的feature-branch(冒号后面的)分支(没有会自动创建)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端Nginx配置]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%89%8D%E7%AB%AFnginx%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言 了解学习在服务器上安装并启动Nginx 参考资料 菜鸟教程 nginx安装配置 笔记 查看系统信息 指令 安装Nginx 遇到的问题 需要升级openssl 基本操作 123// 查找服务ps -ef | grep nginx// 启动]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求]]></title>
    <url>%2F2019%2F03%2F21%2FHTTP%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[前言 通过接口看http请求 login接口 笔记 需要弄清楚http请求报头包括哪些内容 使用场景 CORS 安全性问题等 字段讲解 General Request URL:请求接口url地址 Request Method:请求方法 post get put delete… Status Code：状态码 Remote Address:远程服务器ip Referrer Policy: 来源协议，需要了解，监管哪些访问来源信息 Response Headers Access-Control-Allow-Credentials:响应头表示是否可以将对请求的响应暴露给页面，true则可以，其他都不行。 Access-Control-Allow-Origin:访问控制允许同源，涉及到安全性CORS Cache-Control:缓存控制 Content-Type:返回数据类型 Date:服务器时间 Expires:响应过期的时间，0代表无效 Pragma: 兼容只支持HTTP/1.0协议的缓存服务器相当于Cache-Control作用 Transfer-Encoding:传递给用户采用的编码方式 Vary:一个HTTP响应头部信息，它决定了对于未来的一个请求头 X-Content-Type-Options:响应首部相当于一个提示标志，被服务器用来提示客户端一定要遵循在 Content-Type 首部中对 MIME 类型 的设定，而不能对其进行修改。 X-Frame-Options:是否允许当前页面通过iframe内嵌到其他网站中 X-XSS-Protection:响应头是Internet Explorer，Chrome和Safari的一个功能，当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面。 Request Headers Accept: 发送端希望接受的数据类型 Content-Type:发送端发送的实体数据的类型 Origin:请求来自哪个站点 Referer:首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。 User-Agent:发起请求的用户代理软件信息]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2019%2F03%2F21%2FPromise%2F</url>
    <content type="text"><![CDATA[前言 Promise概念 解决什么问题 用法 疑惑 在 Effective JavaScript 的 第67项 不要对异步回调函数进行同步调用 参考资料 MDN-Promise Promise小书 Promise是什么 Promise是一个对象，是个什么对象？用来表示一个异步操作的最终状态(完成或者失败)，以及该异步操作的结果值。 笔记 Promise() 三种状态 pending FulFilled Rejected时候，对应的处理方法.then .catch 链式调用 Promise().then() 或者.catch() 都会返回一个新的Promise() 用Promise.all() .race() 对多个异步调用进行统一处理 all和race的差别，all是等所有Promise状态确定后(fulfilled或者rejected)才进行后面的处理，race是当某一个Promise状态确定后就会进行后面的处理 使用reject而不是throw来使得Promise状态变为rejected then和catch]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript事件机制]]></title>
    <url>%2F2019%2F03%2F21%2FJavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 了解学习 JavaScript事件机制 Event Loop 单线程怎么做到 非阻塞 参考资料 什么是Event Loop JavaScript 运行机制详解：再谈Event Loop Tasks, microtasks, queues and schedules 这一次彻底弄懂JavaScript执行机制 JS事件循环机制（event loop）之宏任务/微任务 从一道题说JavaScript的事件循环 笔记 核心概念 JavaScript是单线程语言 Event Loop是JavaScript执行机制 执行顺序，js一般的执行顺序都是按正常顺序执行，如果触发了事件比如点击事件或者其他页面上的交互事件，会将事件放到执行栈Stack，然后顺序执行，这就有个问题，比如加载图片很慢会使得页面渲染很慢，所以需要引出异步的概念，对于异步的任务，]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建React]]></title>
    <url>%2F2019%2F03%2F18%2F%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAReact%2F</url>
    <content type="text"><![CDATA[前言 不借助脚手架 create-react-app，自己手工从零开始搭建React App npm 使用 webpack配置 其他 问题 安装babel的 还是babel-cli 以及怎么配置的 babel配置的问题 https://stackoverflow.com/questions/53326986/trace-the-node-type-spreadproperty-has-been-renamed-to-spreadelement-at-object https://github.com/babel/babel/issues/8707 学习 webpack配置 loader plugins babel配置 两种方式 package.json/.babelrc webpack打包过程中 webpack-dev-server 步骤 npm init 安装react 和react-dom 安装打包工具 webpack和webpack-dev-server 安装babel，转es6到es5(？)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工具]]></title>
    <url>%2F2019%2F03%2F17%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[前言 前端工具使用 live-server 起个个本地服务，可以实现热更新 注意：–watch监视当前文件夹路径要写**&quot;.&quot;，而不是&quot;./&quot;**， not work: live-server ./ --port=9000 --watch=./ work: live-server . --port=9000 --watch=.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js高程学习笔记]]></title>
    <url>%2F2019%2F03%2F11%2Fjs%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 重读js高程3的学习笔记，这本书很经典，值得多读几遍。特别是其中的js高级内容，需要很好地去掌握 作用域 原型 原型链 闭包 对象和函数 …]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
