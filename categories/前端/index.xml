<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>前端 on hi~</title><link>http://example.org/categories/%E5%89%8D%E7%AB%AF/</link><description>Recent content in 前端 on hi~</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 29 Apr 2021 17:47:58 +0800</lastBuildDate><atom:link href="http://example.org/categories/%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>当setState之后</title><link>http://example.org/post/%E5%BD%93setstate%E4%B9%8B%E5%90%8E/</link><pubDate>Thu, 29 Apr 2021 17:47:58 +0800</pubDate><guid>http://example.org/post/%E5%BD%93setstate%E4%B9%8B%E5%90%8E/</guid><description>当我们在setState，我们在set什么 前言 本文主要想要了解并学习关于setState后续的一些过程 同步or异步 更新过程 更新过程</description></item><item><title>Redux源码解析createStore</title><link>http://example.org/post/redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90createstore/</link><pubDate>Sat, 24 Apr 2021 22:25:29 +0800</pubDate><guid>http://example.org/post/redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90createstore/</guid><description>前言 该文章主要记录看redux源码时候遇到的疑惑点以及解惑 笔记 redux源码很短，主要核心内容就createStore自己在阅读的时候遇到一</description></item><item><title>Js创建对象的几种方式</title><link>http://example.org/post/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 19 Apr 2021 22:08:49 +0800</pubDate><guid>http://example.org/post/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid><description>&lt;h3 id="前言">前言&lt;/h3>
&lt;ol>
&lt;li>了解js几种创建对象的方式&lt;/li>
&lt;li>了解原型&lt;/li>
&lt;/ol></description></item><item><title>Js深拷贝实现</title><link>http://example.org/post/js%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0/</link><pubDate>Fri, 09 Apr 2021 14:12:02 +0800</pubDate><guid>http://example.org/post/js%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0/</guid><description>为什么需要深拷贝 因为对象在内存中是在堆内存heap中存储，没法直接访问，只能通过地址指针来访问到。所以通常我们在拷贝对象时候只是拷贝了指针地</description></item><item><title>H5歌曲播放页面编写</title><link>http://example.org/post/h5%E6%AD%8C%E6%9B%B2%E6%92%AD%E6%94%BE%E9%A1%B5%E9%9D%A2%E7%BC%96%E5%86%99/</link><pubDate>Thu, 08 Apr 2021 16:21:44 +0800</pubDate><guid>http://example.org/post/h5%E6%AD%8C%E6%9B%B2%E6%92%AD%E6%94%BE%E9%A1%B5%E9%9D%A2%E7%BC%96%E5%86%99/</guid><description>背景 编写音频播放需求 实现 思路： 音频播放就用 audio标签来处理，音频内容挂载到audio元素(ad)上，把该元素隐藏。自己写下ui，然后通过</description></item><item><title>http知识点</title><link>http://example.org/post/http%E7%9F%A5%E8%AF%86%E7%82%B9/</link><pubDate>Tue, 06 Apr 2021 14:08:02 +0800</pubDate><guid>http://example.org/post/http%E7%9F%A5%E8%AF%86%E7%82%B9/</guid><description>&lt;h3 id="前言">前言&lt;/h3>
&lt;ol>
&lt;li>http是什么&lt;/li>
&lt;li>https是什么&lt;/li>
&lt;li>http请求头包含哪些内容&lt;/li>
&lt;li>http建立连接过程&lt;/li>
&lt;li>get post什么区别&lt;/li>
&lt;/ol></description></item><item><title>对js事件循环的理解</title><link>http://example.org/post/%E5%AF%B9js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3/</link><pubDate>Thu, 11 Jun 2020 19:33:04 +0800</pubDate><guid>http://example.org/post/%E5%AF%B9js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3/</guid><description>&lt;h4 id="前言">前言&lt;/h4>
&lt;ol>
&lt;li>了解js作为单线程处理事件的顺序&lt;/li>
&lt;li>宏任务和微任务 同步任务 异步任务&lt;/li>
&lt;li>setTimeout/setInterval&lt;/li>
&lt;/ol></description></item><item><title>防抖和节流</title><link>http://example.org/post/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</link><pubDate>Tue, 19 May 2020 14:31:14 +0800</pubDate><guid>http://example.org/post/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</guid><description>前言 节流防抖 是什么 应用场景区分 实现 参考 https://zhuanlan.zhihu.com/p/38313717 https://juejin.im/post/5b8de829f265da43623c4261 节流和防抖 处理频繁请求的业务场景，比如「输入框keyup实时搜索查询请求」 「页面滚动触发的事件」，</description></item><item><title>前端跨域</title><link>http://example.org/post/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F/</link><pubDate>Mon, 11 May 2020 18:47:53 +0800</pubDate><guid>http://example.org/post/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F/</guid><description>&lt;h3 id="前言">前言&lt;/h3>
&lt;ol>
&lt;li>为什么会产生跨域&lt;/li>
&lt;li>解决方案&lt;/li>
&lt;/ol>
&lt;h3 id="前端跨域产生">前端跨域产生&lt;/h3>
&lt;p>浏览器安全策略 同源策略（同协议域名端口）&lt;/p></description></item></channel></rss>